‚Å°‚Å¢‚Å£‚Å£ùóùùóîùó©ùóîùó¶ùóñùó•ùóúùó£ùóß‚Å°

    Javscript can be added to an html file directly by doing:

    <script>
    // Your javascript goes here
    console.log("Hello World!")
    </script>

    Now, to view your code, you would launch the html file in the browser, open the dev tools, then go to the console to see the message.
    The other way to insert javascript for more complex scripts is to use an external script. Here, just like you link html, you would
    do the same with js by typing:

        <script src="javascript.js"></script>

    And then populate the external script file with the code you want to run

    ‚Å°‚Å¢‚Å£‚Å£Variables
        ‚Å°‚Å¢‚Å¢‚Å£Declare variables in javascript with:
            var, let and const can be used to declare variables‚Å°‚Å°
            ‚Å°‚Å¢‚Å£‚Å£let:‚Å°
                let message = "Hello!";      let user = "John", age = 25, message = "Hello!";
                let user = "John",
                    age 25, message = "Hello";
            ‚Å°‚Å¢‚Å£‚Å£var:‚Å°
                var message = "Hello";
            Case matters: for example, apple and APPLE are two different variables
            Variables can be declared with num = 5 for example, as long as you dont put "use strict" in your script to maintain compatibility
                with older scripts
            ‚Å°‚Å¢‚Å£‚Å£cont:‚Å°
                To create a constant unchanging variable, use const instead of let:
                    const myBirthday = "18.04.1982";
                It is good practice to use constants as aliases for difficult to remember values that are known prior to execution, like color hexes
                    These constants are always named using capital letters and underscores like so: const COLOR_RED = "#F00";
    Alert() can be us9ed to print a variable or message 

    Quote types and Strings:
    "", '', `` can all be used to declare strings. Double and single qutoes are functionally the same thing, however backticks (``) allow you to embed variables
    and expression into a string by wrapping them in ${} for exampe:
        let name = "John";
        alert(`Hello, ${name}!`);

    https://www.w3schools.com/js/js_string_methods.asp - Link that has a lot of commonly used js string methods such as slice, length, etc
    https://www.w3schools.com/jsref/jsref_obj_string.asp - Same as above, with string methods, but also string HTML wrapper methods as well
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String - fully exhaustive list of methods usable on strings
    https://javascript.info/ifelse - Useful stuff on conditional branching that follows the format: (condition) ? (do this if true) : (or else do this)

   ‚Å°‚Å¢‚Å£‚Å£ Functions:‚Å°
        An example of a function in js is this:
            function myFunction(){
                alert("Hello");
            }
        This function would be called by using myFunction(); and would say hello.
        An example of a function with parameters (and a default parameter value is shown below):
            function hello(name = "Adam") {
                console.log(`Hello ${name}!`);
            }
        Anonymous functions are those that are created without a name, and they appear like so:
            (function(){
                alert("Hello");
            });
        When would you really use anonymous functions? You'll often see these when a function expects to receive another function as a parameter. In this case the
        function parameter is often passed as an anonymous function.
            For example, consider you want to run some code when the user types into a text box, you can use addEventListener() with the textbox to do this. This function
                expects you to pass it two parameters -- the name to of the event ot listen for, which in this kay is keydown, and a function to run when the event happens.

                function logKey(event) {
                    console.log(`You pressed "${event.key}".`);
                    }

                textBox.addEventListener("keydown", logKey);
            When the user presses the key, the browser will call the function provided and will pass it a parameter containing the information about the event.
            Instead of defining the separate logkey() function, you can instead pass it an anonymous function:

                textBox.addEventListener("keydown", function (event) {
                    console.log(`You pressed "${event.key}".`);
                    });

            By doing this you essentially gain the ability to put a function as the parameter of another function or event.

        Arrow Functions:
            These are the same as an anonymous function functionally, but you instead write them like so:

            textBox.addEventListener("keydown", (event) => {
                console.log(`You pressed "${event.key}".`);
                });
            
            And if the function is only going to take one parameter anyways, you can omit the parantheses around the parameter like os:

            textBox.addEventListener("keydown", event => {
                console.log(`You pressed "${event.key}".`);
                });

            Finally, if your function only contains one line thats a return statement, you can omit the {} and hte return keyword to implicitly return
                the expression:
            
            const originals = [1, 2, 3];
            const doubled = originals.map(item => item * 2);
            console.log(doubled); // [2, 4, 6]

            In the above code, the map() method of array is used to double every value in the original array.
            In the above, the example (item => item * 2) is functionally the same as this function:

            function doubleItem(item) {
                return item * 2;
                }

            Likewise, you can greatly simplify the above textbox listener function as this:

            textBox.addEventListener("keydown", (event) =>
                console.log(`You pressed "${event.key}".`),
                );
    
    ‚Å°‚Å¢‚Å£‚Å£Function scope and conflicts:
        When you create a function, the variables and other things defined inside the function are inside their own separate scope, meaning that they are locked away in 
            their own separate compartments, unreachable from code outside the functions.
        Top level, outside of functions, is called global scope.
        ‚Å°Inside of a function would entail local scope, and any variables created inside of a function will not be accessible outside of that function unless a return is used.

    ‚Å°‚Å¢‚Å£‚Å£Return and return values:
        These are the values that a function returns when it completes. You've already met return values several times, although you may not have thought about them explicitly.
        ‚Å°To return a value from a custom function, you need to use the "return" keyword.

    Function declaration: A function, declared as a separate statement, in the main code flow:
        // Function Declaration
        function sum(a, b) {
            return a + b;
        }

    Function expression:
        A function, created inside an expression or inside another syntax construct. Here, the function si created on the right side of the assignment expression.
        // Function Expression
        let sum = function(a, b) {
            return a + b;
        };
    
    Most interesting is WHEN these functions would be used. Function expression is only created when the execution reaches it, and is only usable from that point forward.
    Function declarations are different. They can be called earlier than it is defined, as they are created on the start of the code running.

    ‚Å°‚Å¢‚Å£‚Å£Java call stacks:‚Å°
        Works on the LIFO principle, or last-in-first-out. https://www.javascripttutorial.net/javascript-call-stack/ Good tutorial on call-stack order, but not worth typing out notes for.

    Java loops and arrays:
        let fruits = [];
        fruits.forEach(myFunction);

        The forEach method is a powerful and easy way to loop through a function, doing something to
            each element.
        .push() - adds an element to an array
        .length() - returns size of array
        .sort() - sorts the elements in an aray 
        .toString()
        .pop()
        .shift()
        .unshift()
        .join()
        .delete()
        .concat()
        .flat()
        .splice()
        .slice()
        https://www.w3schools.com/js/js_array_methods.asp -- good website with details on these.

        In loops, keep in mind if you have nested loops, and you use the break command, you will only
        break out of the inner loop unless you label the outer loop like this:
            outer: for(){
                for(){
                    break outer;
                }
            }
        You can then call the label that you attached to the outer loop when using break to break out
        to that specific level

    ‚Å°‚Å¢‚Å£‚Å£Working in the DOM tree, and selecting nodes:‚Å°
        const container = document.querySelector('#container');
        // selects the #container div (don't worry about the syntax, we'll get there)

        console.dir(container.firstElementChild);                      
        // selects the first child of #container => .display

        const controls = document.querySelector('.controls');   
        // selects the .controls div

        console.dir(controls.previousElementSibling);                  
        // selects the prior sibling => .display

        Generally, ‚Å°‚Å¢‚Å£‚Å£selection‚Å° takes on this form:
            element.querySelector(selector) -- returns a reference to the first match of selector
            element.querySelectorAll(selectors) -- returns a "nodelist" containing refernces to ALL matches

            Note that even though the result looks like an array it is not. It is a nodelist. To get
                around these limitations, it can be converted to an arary with "Array.from()".

        document.createElement(tagName, [options]) - creates a new element of tag type tagName

      ‚Å°‚Å¢‚Å£‚Å£  Appending Elements:‚Å°
            parentNode.appendChild(childNode) - appends childNode as the last child of parentNode
            parentNode.insertBefore(newNode, referenceNode) - inserts newNode into parentNode before 
                referenceNode

        ‚Å°‚Å¢‚Å£‚Å£Removing elements:‚Å°
            parentNode.removeChild(child) - removes child from parentNode on the DOM and returns a 
                reference to child

        https://domenlightenment.com/#6.2 - massive resources that has a bunch of ways to adjust/alter
            CSS properties using javascript

    ‚Å°‚Å¢‚Å£‚Å£Javascript events:‚Å°
        Events are actions that occur on your webpage such as mouse-clicks or keypresses, and using 
        JavaScript we can make our webpage listen and react to these events.

        There are three primary ways to go about this: You can specify function attributes directly 
        on your HTML elements, you can set properties of form on[eventType] (onclick, onmousedown, 
        etc.) on the DOM nodes in your JavaScript, or you can attach event listeners to the DOM nodes 
        in your JavaScript. Event listeners are definitely the preferred method, but you will 
        regularly see the others in use, so we‚Äôre going to cover all three.

        ‚Å°‚Å¢‚Å£‚Å£Method 1:‚Å°
           <button onclick="alert('Hello World')">Click Me</button> 

           This solution is less than ideal because we‚Äôre cluttering our HTML with JavaScript. 
           Also, we can only set one ‚Äúonclick‚Äù property per DOM element, so we‚Äôre unable to run 
           multiple separate functions in response to a click event using this method.

        ‚Å°‚Å¢‚Å£‚Å£Method 2:‚Å°
           <!-- the HTML file -->
           <button id="btn">Click Me</button>

           // the JavaScript file
           const btn = document.querySelector('#btn');
           btn.onclick = () => alert("Hello World");

           This is a little better. We‚Äôve moved the JS out of the HTML and into a JS file, 
           but we still have the problem that a DOM element can only have 1 ‚Äúonclick‚Äù property.

        ‚Å°‚Å¢‚Å£‚Å£Method 3:‚Å°
           <!-- the HTML file -->
           <button id="btn">Click Me Too</button>

           // the JavaScript file
           const btn = document.querySelector('#btn');
           btn.addEventListener('click', () => {
           alert("Hello World");
           });

           Now, we maintain separation of concerns, and we also allow multiple event listeners if 
           the need arises. Method 3 is much more flexible and powerful, though it is a bit more 
           complex to set up.

       ‚Å°‚Å¢‚Å£‚Å£ Note that all three of these methods can be used with named functions like so:‚Å°
            <!-- the HTML file -->
            <!-- METHOD 1 -->
            <button onclick="alertFunction()">CLICK ME BABY</button>

            // the JavaScript file
            function alertFunction() {
            alert("YAY! YOU DID IT!");
            }

            // METHOD 2
            btn.onclick = alertFunction;

            // METHOD 3
            btn.addEventListener('click', alertFunction);

        https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener -- this has
        decent information about events and handling them. 
        
        For more practical uses, see js-test.js in "change-css-with-js-exercise"

    ‚Å°‚Å¢‚Å£‚Å£Attaching listeners to groups of nodes:‚Å°
        This might seem like a lot of code if you‚Äôre attaching lots of similar event 
        listeners to many elements. There are a few ways to go about doing that more efficiently. 
        We learned above that we can get a nodelist of all of the items matching a specific selector 
        with querySelectorAll('selector'). In order to add a listener to each of them we simply 
        need to iterate through the whole list like so:

        <!-- In HTML -->
        <div id="container">
            <button id="1">Click Me</button>
            <button id="2">Click Me</button>
            <button id="3">Click Me</button>
        </div>

        // buttons is a node list. It looks and acts much like an array.
        const buttons = document.querySelectorAll('button');

        // we use the .forEach method to iterate through each button
        buttons.forEach((button) => {

        // and for each one we add a 'click' listener
        button.addEventListener('click', () => {
            alert(button.id);
        });
        });

    https://www.w3schools.com/jsref/dom_obj_event.asp -- comprehensive list of DOM events



